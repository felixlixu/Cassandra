package org.apache.cassandra.service;

import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeoutException;

import javax.management.MBeanServer;
import javax.management.ObjectName;

import org.apache.cassandra.db.IMutation;
import org.apache.cassandra.db.ReadCommand;
import org.apache.cassandra.db.Row;
import org.apache.cassandra.thrift.ConsistencyLevel;
import org.apache.cassandra.thrift.UnavailableException;
import org.apache.cassandra.utils.LatencyTracker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StorageProxy implements StorageProxyMBean {

	private static final Logger logger = LoggerFactory.getLogger(StorageProxy.class);
	
	private static final LatencyTracker readStats=new LatencyTracker();
	public static final StorageProxy instance=new StorageProxy();

	private static final WritePerformer standardWritePerformer;
	
	public static List<Row> read(List<ReadCommand> commands,
			ConsistencyLevel consistency_level) throws UnavailableException {
		if(StorageService.instance.isBootstrapMode())
			throw new UnavailableException();
		long startTime=System.nanoTime();
		List<Row> rows;
		try{
			rows=fetchRows(commands,consistency_level);
		}finally{
			readStats.addNano(System.nanoTime()-startTime);
		}
		return rows;
	}

	private StorageProxy(){}
	
	static{
		MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
		
		try{
			mbs.registerMBean(new StorageProxy(), new ObjectName("org.apache.cassandra.db:type=StorageProxy"));
		}catch(Exception e){
			throw new RuntimeException(e);
		}
		
		standardWritePerformer=new WritePerformer();
		
	}
	
	private static List<Row> fetchRows(List<ReadCommand> initialCommands,
			ConsistencyLevel consistency_level) {
		List<Row> rows=new ArrayList<Row>(initialCommands.size());
		List<ReadCommand> commandsToRetry=Collections.emptyList();
		do{
			List<ReadCommand> commands=commandsToRetry.isEmpty()?initialCommands:commandsToRetry;
			ReadCallback<Row>[] readCallbacks=new ReadCallback[commands.size()];
			if(!commandsToRetry.isEmpty()){
				 logger.debug("Retrying {} commands", commandsToRetry.size());
			}
			
			for(int i=0;i<commands.size();i++){
				ReadCommand command=commands.get(i);
				assert !command.isDigestQuery();
				logger.debug("Command/ConsistencyLevel is {}/{}", command, consistency_level);
				
				List<InetAddress> endpoints=StorageService.instance.getLiveNaturalEndpoints(command.table,command.key);
			}
		}while(!commandsToRetry.isEmpty());
		return rows;
	}

	public interface WritePerformer{
		public void apply(IMutation mutation,Collection<InetAddress> target,IWriteResponseHandler responseHandler,String localDataCenter,ConsistencyLevel consistency_level) throws IOException,TimeoutException;
	}
}
