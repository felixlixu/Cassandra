package org.apache.cassandra.service;

import java.net.InetAddress;
import java.util.List;

import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.ReadCommand;
import org.apache.cassandra.db.Table;
import org.apache.cassandra.net.IAsyncCallback;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.thrift.ConsistencyLevel;
import org.apache.cassandra.utils.FBUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ReadCallback<T> implements IAsyncCallback {

	protected static final Logger logger = LoggerFactory.getLogger( ReadCallback.class );
	private final IReadCommand command;
	private final int blockfor;
	private final IResponseResolver<T> resolver;
	private final long startTime;	
	
	public ReadCallback(IResponseResolver<T> resolver,
			ConsistencyLevel consistency_level, IReadCommand command,
			List<InetAddress> endpoints) {
		this.command=command;
		this.blockfor=determineBlockFor(consistency_level,command.getKeyspace());
		this.resolver=resolver;
		this.startTime=System.currentTimeMillis();
		boolean repair=randomlyReadRepair();
	}

	public int determineBlockFor(ConsistencyLevel consistency_level,
			String table) {
		switch(consistency_level){
			case ONE:
				return 1;
			case TWO:
				return 2;
			case THREE:
				return 3;
			case QUORUM:
				return (Table.open(table).getReplicationStrategy().getReplicationFactor()/2);
			case ALL:
				return Table.open(table).getReplicationStrategy().getReplicationFactor();
			default:
				throw new UnsupportedOperationException("invalid consistency level: " + consistency_level);
		}
	}

	private boolean randomlyReadRepair() {
		if(resolver instanceof RowDigestResolver){
			assert command instanceof ReadCommand:command;
			String table=((RowDigestResolver)resolver).table;
			String columnFamily=((ReadCommand)command).getColumnFamilyName();
			CFMetaData cfmd=Schema.instance.getTableMetaData(table).get(columnFamily);
			return cfmd.getReadRepairChance()>FBUtilities.threadLocalRandom().nextDouble();
		}
		return false;
	}

	@Override
	public boolean isLatencyForSnitch() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void response(Message msg) {
		// TODO Auto-generated method stub
		
	}

}
